# Data-Driven System Demo (EF Core vs. ADO.NET)

This project demonstrates database management in a simple commercial system using two different approaches within a C# environment. The goal is to compare **Microsoft Entity Framework Core (ORM)** and native **ADO.NET** technologies, highlighting the strengths and usage patterns of both.

## üìã Project Overview

The system manages a relational database consisting of three tables (MSSQL), containing the following entities:
* **Category**: Product categories.
* **Product**: Products belonging to categories.
* **Order**: Orders referencing products.

The project demonstrates how to query data, insert records, and handle transactions using both technologies.

## üõ†Ô∏è Technologies Used

* **.NET (C#)**
* **Microsoft SQL Server (LocalDB)**
* **Entity Framework Core (EF Core):** Database-First approach.
* **ADO.NET (Microsoft.Data.SqlClient):** Low-level database management.

---

## üóÑÔ∏è Database Structure (Schema)

The database model is built on the following relationships:
1.  **Category (1) ‚Üî (N) Product**: One category can contain multiple products.
2.  **Product (1) ‚Üî (N) Order**: One product can be associated with multiple orders.

### Key SQL Constraints:
* **Primary Keys**: `ID` (Identity)
* **Foreign Keys**: `Product.CategoryID`, `Order.ProductID`

---

## üìÇ Project Structure and Files

The project consists of the following main components:

### 1. Entities (`Entities/`)
POCO (Plain Old CLR Object) classes generated by the `Scaffold-DbContext` command, representing the database tables.
* **`Category.cs`**: Category definition and navigation property for products.
* **`Product.cs`**: Product definition, price, stock, VAT, XML description.
* **`Order.cs`**: Order data, dates, status.

### 2. Entity Framework Core Implementation
Using the **Database-First** approach, the code was generated from the existing SQL schema.
* **`MyDbContext.cs`**: The central element of the database connection.
    * Contains `DbSet` properties (`Categories`, `Orders`, `Products`).
    * Uses the `OnModelCreating` method to define table relationships (e.g., `HasOne`, `WithMany`) and field types via the **Fluent API**.
* **`LINQQUeries.cs`**: An example class that uses **LINQ (Language Integrated Query)** to query data from the database simply and readably.

### 3. ADO.NET Implementation (`Repositories/`)
This layer demonstrates "manual" control, without ORM magic, using pure SQL and C# code.
* **`MyAdoNetRepository.cs`**: Contains business logic using SQL commands.
    * **Connection Management**: Uses `SqlConnection` within `using` blocks to prevent connection leaks.
    * **CRUD Operations**: Implements `INSERT` and `SELECT` using parameterized queries (SQL Injection protection).
    * **Manual Mapping**: Manually transforms `SqlDataReader` results into C# objects.
    * **Transaction Management**: The `PlaceOrderWithTransaction` method demonstrates how to handle order placement and stock reduction as an atomic operation (`SqlTransaction`).

---

## ‚öôÔ∏è Setup and Run

### Entity Framework (LINQ) Example
1. Create Database: Run the provided T-SQL script (CreateSchema.sql and InsertData.sql - assuming these files exist in your project) on your MS SQL Server.
2. Configure Connection String: Check the Data Source setting in MyDbContext.cs and MyAdoNetRepository.cs:
```bash
"Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=CsharpProject;Integrated Security=True"
```
3. Scaffolding (If regeneration is needed): If the database schema changes, you can update the EF Core model using the following command (Package Manager Console):
```bash
Scaffold-DbContext 'Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=CsharpProject;Integrated Security=True' Microsoft.EntityFrameworkCore.SqlServer -Context MyDbContext -OutputDir Entities -Force
```
